#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
   Author: Jorge de la Peña García
   Author: Carlos Martínez Cortés
   Email:  cmartinez1@ucam.edu
"""
from collections import OrderedDict
import argparse
import os
from os.path import join, basename, splitext, isfile
import re
import sys
import fnmatch
from shutil import copyfile
import subprocess
import json
import datetime

PYTHON_RUN = 'python'
PLIP_SCRIPT = PYTHON_RUN + " " + join('MetaScreener', 'extra_metascreener', 'used_by_metascreener',
                                      'create_ligand_plip.py {} {} {}')
PYMOL_SCRIPT = PYTHON_RUN + " " + join('MetaScreener', 'extra_metascreener', 'used_by_metascreener',
                                       'create_ligand_pymol.py {} {} {} {} {} {}')
PML_HEAD_PYMOL = PYTHON_RUN + " MetaScreener/extra_metascreener/used_by_metascreener/create_header_pml.py -t {}"
FILE_EXT = {}
FILE_EXT["AD"] = [ '.pdbqt', '.json' ]
FILE_EXT["LF"] = [ '.mol2', '.json' ]

def is_dir(dirname):
    """Checks if a path is an actual directory"""
    if not os.path.isdir(dirname):
        msg = "{0} is not a directory".format(dirname)
        raise argparse.ArgumentTypeError(msg)
    else:
        return dirname


def read_file(file_cross):
    """
        Receives a file with the cross_list_vs format and returns a list with each line in an array
        :param str file_cross:
        :return: list with each line in an array
    """
    lst_cross = []
    with open(file_cross) as fp:
        for line in fp:
            if line.startswith(' '):  # if you start with this mark it means that it is the header
                line = re.sub(' +', ' ', line.strip())
                lst_cross.append(line.split(" "))
    return lst_cross


def filter(lst_cross):
    """
         Filters the data with a certain method
        :param lst_cross: list with each line in an array
        :param int num: number of tests that can fail
        :return:
    """
    data = []
    for line in lst_cross:
        if (line.count('--')) == 0:
            data.append(line)
    return data

def read_paths(lst_data):
    ligands = {}
    lst_files = []
    for line in lst_data:
        for sw in header:
            for i in range(2, len(line[:-1]), 3):
                if fnmatch.fnmatch(line[i], '*_' + sw + '_*'):
                    for ext in FILE_EXT[sw]:
                        if ext == ".json":
                            lst_files.append(line[i] + ext)
                        else:
                            lst_files.append(line[i].replace("/energies/","/molecules/") + ext)
                    if sw not in ligands:
                        ligands[sw] = {}
                    ligands[sw][line[-1]] = lst_files
                    lst_files = []
    return ligands

def classification_strategy(lst_data, method):
    """
         Classification Strategy
        :param lst_data:
        :param header:
        :return: dictionary sorted by score
    """
    dict = {}
    for line in lst_data:
        sum = getattr(sys.modules[__name__], method)(line)
        if sum not in dict:
            dict[sum] = line
        else:
            while (sum not in dict):
                sum = str(sum) + 1
            dict[sum] = line
    dict = OrderedDict(sorter(dict)[:args.max_results])

    if args.verbose:
        for k, v in dict.items():
            print('{:8.2f}'.format(k), v)
    return dict


def sorter(data):
    """
        Sort dictinary
        :param data: dict
        :return:
    """
    return sorted(data.items(), key=lambda kv: kv[0], reverse=False)


def by_rank(line):
    """
        Adds the rankings of each program
        :param line:
        :return:
    """
    sum = 0
    cnt = 0
    for i in range(0, len(line[:-1]), 3):
        if not '--' in line[i]:
            cnt += 1
            sum += int(line[i])
    return sum / cnt


def by_score(line):
    """
        adds the scores of each program
        :param line:
        :return: sum
    """
    sum = 0
    cnt = 0
    for i in range(1, len(line[:-1]), 3):
        if not '--' in line[i]:
            cnt += 1
            sum += float(line[i])
    return sum / cnt


def make_folder(folder):
    """
        if it does not exist, create the folder
        :param str folder: name folder
        :return:
    """
    if not os.path.isdir(folder):
        os.makedirs(folder)


def params():
    """
        Collects the input parameters
        :return:
    """
    parser = argparse.ArgumentParser(
        description='Receive a file with VS cross lists and folders and generate a pymol session.',
        epilog='Copyright 2019 Autor bajo licencia GPL v3.0'
    )

    parser.add_argument('-f', '--file', type=argparse.FileType('r'), required=True, help='output cross_list_vs')
    parser.add_argument('-d', '--dirs', action='append', nargs='+',
                        help='Root folder generated by metascreener example: VS_AD_5hex_rec_DB-201016_PQ_31_-4_-65_2018-11-26',
                        required=True, type=is_dir)
    parser.add_argument('-r', '--receptor', required=True, type=argparse.FileType('r'), help='receptor')
    parser.add_argument('-o', '--output', required=True, help='Output folder')
    parser.add_argument('-m', '--max_results', default=100, help='Max Results', type=int)
    parser.add_argument('-p', '--pse', default=False, help='Copy pse', action='store_true')
    parser.add_argument('-v', '--verbose', help='Verbose', action='store_true')

    return parser.parse_args()


def cp_files(files, folder):
    """
        Copies the files to the specified folder

        :param [] files:
        :param str folder:
        :return:
    """
    for file in files:
        copyfile(file, join(folder, basename(file)))


def get_string_pattern(lst, pattern):
    """
        Returns the string of the list based on the pattern

        :param pattern:
        :return:
    """
    for i in lst:
        if pattern in i:
            return i
    return False


def get_file_molecule(list):
    if "_AD_" in str(list):
        ext = ".pdbqt"
    elif "_LF_" in str(list):
        ext = '.mol2'
    else:
        "Error: Software not supported"
        exit()
    query = get_string_pattern(files, ext)
    if query:
        return query
    print("Error: get_file_molecule: Molecules not found ")
    exit()


def write_file(lst_pml, file):
    """
        "writes a list of lines to a plain text file

        :param lst_pml: list of lines
        :param file: output file
        :return:
    """
    f = open(file, "w")
    for i in lst_pml:
        f.write(i)
    f.close()


def add_receptor(receptor, folder_molecules):
    """
        Copy the protein to the folder of molecules and return the necessary lines pea insert it into the pml
        :param receptor:
        :param folder_molecules:
        :return:
    """

    cp_files([receptor], folder_molecules)
    receptor = "Molecules/" + basename(receptor)
    cmd = PML_HEAD_PYMOL.format(receptor)
    return subprocess.check_output(cmd, shell=True).decode('UTF-8')

def read_json(file):
    """
        Reads a json file and returns its dictionary
        :param str file:
        :return:
    """
    if file:
        with open(file, 'r') as f:
            datastore = json.load(f)
    return datastore


def execute_command(cmd):
    """
        Execute commands

        :param cmd: command
        :return:
    """
    if args.verbose:
        print(cmd)
    return subprocess.check_output(cmd, shell=True).decode('UTF-8')


if __name__ == "__main__":
    args = params()
    args.dirs = args.dirs[0]
    args.output = '{}_{}'.format(args.output, datetime.date.today())
    with open(args.file.name) as f:
        header = f.readline().strip().replace(',', '').split(" ")
    if args.pse:
        FILE_EXT.append('.pse')
    out_molecs = join(args.output, 'Molecules', '')
    make_folder(args.output)
    make_folder(out_molecs)
    #
    #   Sort data
    #
    lst_cross = read_file(args.file.name)
    lst_data = filter(lst_cross)
    ligands = read_paths(lst_data)
    for method in ['by_score', 'by_rank']:
        pml_file = join(args.output, '{}_{}.pml'.format(0, method))
        dict_sort = classification_strategy(lst_data, method)
        #
        # copy files
        #
        pml_lst = [add_receptor(args.receptor.name, out_molecs)]
        cnt_cluster = 1
        for k, v in dict_sort.items():
            print(k, v)
            group = []
            g_ranks = []
            for sw in range(len(header)):
                if v[sw * 2] != '--':
                    g_ranks.append(header[sw] + "_" + v[sw * 2])
                    if args.verbose:
                        print('Search: *_{}_*'.format(v[-1]))
                    files = ligands[header[sw]][v[-1]]
                    print(files)
                    if (len(files) == 0):
                        print("ERROR: " + v[-1] + " not found. Check if there are any issues with cross_list_vs or any of the metascreener executions.")
                    cp_files(files, out_molecs)
                    query = get_file_molecule(files)
                    name_query = basename(query)

                    query = join(out_molecs, name_query)
                    prefix = join(out_molecs, splitext(name_query)[0])

                    out_json_plip = '{}_interactions.json'.format(splitext(query)[0])
                    if not get_string_pattern(files, 'interactions'):
                        if not isfile(out_json_plip):  # if not exists interactions file
                            execute_command(PLIP_SCRIPT.format(args.receptor.name, query, prefix))

                    interactions_file = prefix + '_interactions.json'
                    energy_json = prefix + '.json'
                    cmd = PYMOL_SCRIPT.format('../' + query, energy_json, interactions_file, 0, False, "STANDARD_VS")
                    pml_lst.append(execute_command(cmd))

                    score = round(float(read_json(energy_json)['global_score']), 2)

                    group.append('{}_{}'.format(splitext(name_query)[0], score))
            pml_lst.append(
                "cmd.group('CL_{} {} ( {} )', '{}')\n".format(cnt_cluster, round(k, 3), ' '.join(g_ranks),
                                                                  ' '.join(group)))
            cnt_cluster += 1

        write_file(pml_lst, pml_file)
